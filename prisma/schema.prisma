datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model School {
  id                Int            @id @default(autoincrement())
  name              String
  subdomain         String         @unique
  logo              String?
  schoolCode        String         @unique
  schoolType        SchoolType     @default(CBT)
  status            String?        @default("active")
  plan              String         @default("free")
  subscriptionStart DateTime?
  subscriptionEnd   DateTime?
  settings          Json?
  permissions       Json?
  analytics         Json?
  adminEmail        String?
  adminPassword     String?
  adminRoles        Json?
  adminUsers        AdminUser[]
  students          Student[]
  exams             Exam[]
  departments       Department[]
  subscriptions     Subscription[]
  accessKeys        AccessKey[]
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  suspendedAt       DateTime?
  suspensionNote    String?
  isDeleted         Boolean        @default(false)
}

enum SchoolType {
  HIGH_SCHOOL
  TERTIARY
  CBT
}

model Department {
  id                     String    @id @default(cuid())
  name                   String
  code                   String?
  schoolId               Int
  school                 School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  students               Student[]
  courses                Course[]
  admissionFormatRegex   String?
  admissionFormatPreview String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
}

model Course {
  id           String       @id @default(cuid())
  name         String
  code         String
  departmentId String
  department   Department   @relation(fields: [departmentId], references: [id])
  results      ExamResult[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model Student {
  id                   Int         @id @default(autoincrement())
  rollNumber           String      @unique
  admissionNo          String
  admissionFormatValid Boolean?    @default(true)
  role                 String      @default("student")
  status               String      @default("pending")
  password             String
  firstName            String
  lastName             String
  gender               String
  email                String      @unique
  contactNumber        String?
  dob                  DateTime?
  academicYear         String?
  level                String?
  term                 String?
  semester             String?
  class                String?
  departmentId         String?
  department           Department? @relation(fields: [departmentId], references: [id])
  schoolId             Int
  school               School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  approvalStatus       String      @default("pending")
  isActive             Boolean     @default(true)
  approvedBy           String?
  approvedAt           DateTime?
  performance          Json?
  loginAttempts        Int?        @default(0)
  lastLogin            DateTime?
  resetToken           String?
  resetTokenExpiry     DateTime?
  subdomain            String?
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  results       Result[]           @relation("StudentResults")
  accessCodes   ResultAccessCode[]
  examsTaken    Exam[]
  notifications Notification[]     @relation("StudentNotifications")
  examResults   ExamResult[]
}

model Exam {
  id           String     @id @default(cuid())
  examTitle    String
  examCode     String     @unique
  mode         ExamMode
  examTypes    ExamType[]
  departmentId String?
  levelId      String?
  classId      String?
  sessionYear  String
  startDate    DateTime
  endDate      DateTime
  duration     Int
  isResit      Boolean    @default(false)
  linkedExamId String?
  status       ExamStatus @default(PENDING)
  createdById  String
  schoolId     Int
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relations
  results       ExamResult[]
  notifications ExamNotification[]
  school        School             @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  students      Student[]
  examResults   Result[]           @relation("ExamResults") // âœ… FIXED: Same relation name
  accessCodes   ResultAccessCode[]

  papers   ExamPaper[]
  settings ExamSettings?

  @@index([examCode])
}

enum ExamMode {
  ONLINE
  OFFLINE
}

enum ExamStatus {
  PENDING
  APPROVED
  LIVE
  CLOSED
}

enum ExamType {
  OBJECTIVE
  THEORY
  PRACTICAL
}

model ExamResult {
  id        String       @id @default(cuid())
  examId    String
  studentId Int
  courseId  String
  score     Float?
  status    ResultStatus @default(PENDING)
  isResit   Boolean      @default(false)
  createdAt DateTime     @default(now())

  exam    Exam    @relation(fields: [examId], references: [id])
  student Student @relation(fields: [studentId], references: [id])
  course  Course  @relation(fields: [courseId], references: [id])
}

enum ResultStatus {
  PENDING
  PASSED
  FAILED
}

model ExamNotification {
  id        String   @id @default(cuid())
  examId    String
  message   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  exam Exam @relation(fields: [examId], references: [id])
}

model Result {
  id           Int      @id @default(autoincrement())
  admission_no String
  roll_number  String
  result_type  String
  exam_name    String
  exam_type    String
  semester     String
  exam_year    Int
  course       String
  score        Int
  remarks      String?
  created_at   DateTime @default(now())

  student   Student @relation("StudentResults", fields: [studentId], references: [id])
  studentId Int

  exam   Exam   @relation("ExamResults", fields: [examId], references: [id])
  examId String

  accessCodes ResultAccessCode[]
}

model ResultAccessCode {
  id        Int     @id @default(autoincrement())
  student   Student @relation(fields: [studentId], references: [id])
  studentId Int
  exam      Exam    @relation(fields: [examId], references: [id])
  examId    String
  result    Result? @relation(fields: [resultId], references: [id])
  resultId  Int?

  code      String @unique
  maxUses   Int    @default(3)
  usedCount Int    @default(0)

  createdAt DateTime @default(now())
}

model Notification {
  id        Int      @id @default(autoincrement())
  title     String
  message   String
  type      String
  isRead    Boolean  @default(false)
  studentId Int
  student   Student  @relation("StudentNotifications", fields: [studentId], references: [id])
  createdAt DateTime @default(now())
}

model AdminUser {
  id          Int       @id @default(autoincrement())
  schoolId    Int
  firstName   String
  lastName    String
  email       String    @unique
  password    String
  role        String // e.g. "general-admin", "admission-officer", "exam-officer"
  status      String    @default("active")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  school      School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  suspendedAt DateTime?
  suspendedBy Int?
}

model SuperAdmin {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  password  String
  role      String   @default("superadmin")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ðŸ”¹ Relations
  logs                SystemLog[]
  accessKeys          AccessKey[]
  platformSettings    PlatformSetting[]
  globalNotifications GlobalNotification[]
}

model SystemLog {
  id         Int      @id @default(autoincrement())
  actorType  String // "superadmin", "admin", "student"
  actorId    Int?
  action     String // "CREATE_SCHOOL", "UPDATE_STUDENT", "APPROVE_EXAM", etc.
  entityType String // "School", "Exam", "Student", "Result"
  entityId   String?
  details    Json?
  timestamp  DateTime @default(now())

  superAdmin   SuperAdmin? @relation(fields: [superAdminId], references: [id])
  superAdminId Int?
}

model PlatformSetting {
  id          Int         @id @default(autoincrement())
  key         String      @unique
  value       Json
  description String?
  updatedAt   DateTime    @updatedAt
  updatedById Int?
  updatedBy   SuperAdmin? @relation(fields: [updatedById], references: [id])
}

model Subscription {
  id            Int       @id @default(autoincrement())
  schoolId      Int
  school        School    @relation(fields: [schoolId], references: [id])
  plan          String
  status        String    @default("active")
  amount        Float
  reference     String?
  paymentMethod String?
  startedAt     DateTime  @default(now())
  expiresAt     DateTime?
  createdAt     DateTime  @default(now())
}

model GlobalNotification {
  id         Int         @id @default(autoincrement())
  title      String
  message    String
  targetType String // "school", "admin", "all"
  targetId   Int?
  isRead     Boolean     @default(false)
  createdAt  DateTime    @default(now())
  createdBy  Int?
  superAdmin SuperAdmin? @relation(fields: [createdBy], references: [id])
}

model AccessKey {
  id          Int         @id @default(autoincrement())
  key         String      @unique
  type        String // "supervisor", "result-pin", "resit", etc.
  schoolId    Int?
  school      School?     @relation(fields: [schoolId], references: [id])
  usageCount  Int         @default(0)
  maxUses     Int         @default(1)
  expiresAt   DateTime?
  createdById Int?
  createdBy   SuperAdmin? @relation(fields: [createdById], references: [id])
  createdAt   DateTime    @default(now())
}

model ExamPaper {
  id               String   @id @default(cuid())
  examId           String
  name             String
  type             ExamType // OBJECTIVE, THEORY, PRACTICAL, MIXED
  duration         Int
  totalMarks       Int
  totalQuestions   Int
  shuffleQuestions Boolean  @default(true)
  shuffleOptions   Boolean  @default(true)
  negativeMarking  Boolean  @default(false)

  exam Exam @relation(fields: [examId], references: [id], onDelete: Cascade)

  objectiveQuestions ObjectiveQuestion[]
  theoryQuestions    TheoryQuestion[]
  practicalItems     PracticalChecklist[]
}

model ObjectiveQuestion {
  id      String  @id @default(cuid())
  paperId String
  text    String
  optionA String
  optionB String
  optionC String
  optionD String
  optionE String?
  correct String?
  marks   Int     @default(1)

  paper ExamPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
}

model TheoryQuestion {
  id      String @id @default(cuid())
  paperId String
  text    String
  marks   Int

  paper ExamPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
}

model PracticalChecklist {
  id       String @id @default(cuid())
  paperId  String
  itemText String
  maxScore Int    @default(1)

  paper ExamPaper @relation(fields: [paperId], references: [id], onDelete: Cascade)
}

model ExamSettings {
  id                      String  @id @default(cuid())
  examId                  String  @unique // âœ… FIXED: must be unique
  allowBackNavigation     Boolean @default(true)
  allowReviewBeforeSubmit Boolean @default(true)
  showScoreAfterExam      Boolean @default(false)
  autoSubmitOnTimeout     Boolean @default(true)
  offlineAllowed          Boolean @default(false)
  attemptLimit            Int     @default(1)
  internalNotes           String?

  exam Exam @relation(fields: [examId], references: [id], onDelete: Cascade)
}
